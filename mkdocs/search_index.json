{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to MkDocs\n\n\nFor full documentation visit \nmkdocs.org\n.\n\n\nCommands\n\n\n\n\nmkdocs new [dir-name]\n - Create a new project.\n\n\nmkdocs serve\n - Start the live-reloading docs server.\n\n\nmkdocs build\n - Build the documentation site.\n\n\nmkdocs help\n - Print this help message.\n\n\n\n\nProject layout\n\n\nmkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-mkdocs", 
            "text": "For full documentation visit  mkdocs.org .", 
            "title": "Welcome to MkDocs"
        }, 
        {
            "location": "/#commands", 
            "text": "mkdocs new [dir-name]  - Create a new project.  mkdocs serve  - Start the live-reloading docs server.  mkdocs build  - Build the documentation site.  mkdocs help  - Print this help message.", 
            "title": "Commands"
        }, 
        {
            "location": "/#project-layout", 
            "text": "mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.", 
            "title": "Project layout"
        }, 
        {
            "location": "/bugs/", 
            "text": "Bugs\n\n\nGCC\n\n\nBug 54812\n: \nprivate\n \n=default\n destructor is \npublic\n\n\nDelete expression doesn't respect access of defaulted destructor\n\n\nstruct Base\n{\n private:\n  ~Base() = default;\n};\n\nint main()\n{\n  Base* p = new Base;\n  delete p;\n}\n\n\n\n\n\n\nQuote:\n The bug affects protected destructors too, and they're commonly used for base classes to prevent deletion via pointer-to-base.\n\n\n\n\nFixed in 4.9.0, by \nr203985\n.\nTest case added by \nr204057\n.\n\n\nGlibc\n\n\nstrstr(3)\n\n\nSince glibc 2.9, strstr(3) may use \nTwo Way algorithm\n in some cases, but the impl. had several bugs:\n\n\n\n\nBug 12092\n\n\nBug 12100\n\n\nBug 14602\n\n\nMore?", 
            "title": "Bugs"
        }, 
        {
            "location": "/bugs/#bugs", 
            "text": "", 
            "title": "Bugs"
        }, 
        {
            "location": "/bugs/#gcc", 
            "text": "", 
            "title": "GCC"
        }, 
        {
            "location": "/bugs/#bug-54812-private-default-destructor-is-public", 
            "text": "Delete expression doesn't respect access of defaulted destructor  struct Base\n{\n private:\n  ~Base() = default;\n};\n\nint main()\n{\n  Base* p = new Base;\n  delete p;\n}   Quote:  The bug affects protected destructors too, and they're commonly used for base classes to prevent deletion via pointer-to-base.   Fixed in 4.9.0, by  r203985 .\nTest case added by  r204057 .", 
            "title": "Bug 54812: private =default destructor is public"
        }, 
        {
            "location": "/bugs/#glibc", 
            "text": "", 
            "title": "Glibc"
        }, 
        {
            "location": "/bugs/#strstr3", 
            "text": "Since glibc 2.9, strstr(3) may use  Two Way algorithm  in some cases, but the impl. had several bugs:   Bug 12092  Bug 12100  Bug 14602  More?", 
            "title": "strstr(3)"
        }, 
        {
            "location": "/kernel/data-structures/", 
            "text": "family\n\n\ntype\n\n\nprotocol\n\n\n\n\n\n\n\n\n\n\nAF_UNIX=1\n\n\nSOCK_STREAM=1\n\n\n0\n\n\n\n\n\n\nAF_UNIX\n\n\nSOCK_DGRAM=2\n\n\n0\n\n\n\n\n\n\nAF_INET=2\n\n\nSOCK_STREAM\n\n\nIPPROTO_TCP=6\n\n\n\n\n\n\nAF_INET\n\n\nSOCK_DGRAM\n\n\nIPPROTO_UDP=17\n\n\n\n\n\n\nAF_INET\n\n\nSOCK_DGRAM\n\n\nIPPROTO_ICMP=1\n\n\n\n\n\n\nAF_INET\n\n\nSOCK_RAW=3\n\n\nIPPROTO_IP=0\n\n\n\n\n\n\nNPROTO=AF_MAX=41\n\n\nSOCK_MAX=11\n\n\nno max?\n\n\n\n\n\n\n\n\nnet_proto_family\n\n\n// include/linux/net.h\n// How to create a socket for an address family\nstruct net_proto_family {\n  int family;  // AF_INET, AF_UNIX, AF_INET6, etc. must: 0 \n= family \n NPROTO\n  int (*create)(struct net *net, struct socket *sock, int protocol, int kern);\n  struct module *owner;\n};\n\n\n\n\n\n// net/socket.c\nstatic const struct net_proto_family *net_families[NPROTO];\n\n// net/ipv4/af_inet.c\nstatic int inet_create(struct net *net, struct socket *sock, int protocol, int kern);\n\nstatic const struct net_proto_family inet_family_ops = {\n  .family = PF_INET,\n  .create = inet_create,\n  .owner  = THIS_MODULE\n};\n\n// inet_init() calls sock_register():\nnet_families[AF_INET] = \ninet_family_ops;\n\n\n\n\nint sys_socket(int family, int type, int protocol)\n  -\n struct socket* sock_create(family, type, protocol)\n    -\n __sock_create(family, type, protocol)\n      -\n struct socket* sock = sock_alloc()\n        -\n new_inode_pseudo(super_block of sockfs)      // fs/inode.c\n      -\n net_families[family]-\ncreate(sock, protocol)\n        -\n inet_create(sock, protocol)                  // net/ipv4/af_inet.c\n  -\n sock_map_fd()\n\ninet_create(sock, protocol)\n  -\n find inet_protosw for sock-\ntype \n protocol\n  -\n struct sock* sk = sk_alloc()\n    -\n sk_prot_alloc -\n kmem_cache_alloc (tcp_prot is 1296B)\n  -\n sock_init_data\n  -\n sk-\nsk_prot-\ninit(sk)\n    -\n tcp_v4_init_sock\n\n\n\n\ninet_protosw\n\n\n// include/net/protocol.h\n/* This is used to register socket interfaces for IP protocols.  */\nstruct inet_protosw {\n  struct list_head list;\n\n  /* These two fields form the lookup key.  */\n  unsigned short   type;     /* This is the 2nd argument to socket(2).  eg. SOCK_STREAM, SOCK_DGRAM */\n  unsigned short   protocol; /* This is the L4 protocol number.  eg. IPPROTO_TCP, IPPROTO_TCP */\n\n  struct proto           *prot;\n  const struct proto_ops *ops;\n\n  unsigned char    flags;      /* See INET_PROTOSW_* below.  */\n};\n#define INET_PROTOSW_REUSE      0x01  /* Are ports automatically reusable? */\n#define INET_PROTOSW_PERMANENT  0x02  /* Permanent protocols are unremovable. */\n#define INET_PROTOSW_ICSK       0x04  /* Is this an inet_connection_sock? */\n\n\n\n\n// net/ipv4/af_inet.c\n/* The inetsw table contains everything that inet_create needs to\n * build a new socket.\n */\nstatic struct list_head inetsw[SOCK_MAX];\nstatic DEFINE_SPINLOCK(inetsw_lock);\n\n/* Upon startup we insert all the elements in inetsw_array[] into\n * the linked list inetsw.\n */\nstatic struct inet_protosw inetsw_array[] =\n{\n  {\n    .type =       SOCK_STREAM,\n    .protocol =   IPPROTO_TCP,\n    .prot =       \ntcp_prot,\n    .ops =        \ninet_stream_ops,\n    .flags =      INET_PROTOSW_PERMANENT | INET_PROTOSW_ICSK,\n  },\n  {\n    .type =       SOCK_DGRAM,\n    .protocol =   IPPROTO_UDP,\n    .prot =       \nudp_prot,\n    .ops =        \ninet_dgram_ops,\n    .flags =      INET_PROTOSW_PERMANENT,\n  },\n  {\n    .type =       SOCK_DGRAM,\n    .protocol =   IPPROTO_ICMP,\n    .prot =       \nping_prot,\n    .ops =        \ninet_dgram_ops,\n    .flags =      INET_PROTOSW_REUSE,\n  },\n  {\n    .type =       SOCK_RAW,\n    .protocol =   IPPROTO_IP,        /* wild card */\n    .prot =       \nraw_prot,\n    .ops =        \ninet_sockraw_ops,\n    .flags =      INET_PROTOSW_REUSE,\n  }\n};\n\n#define INETSW_ARRAY_LEN ARRAY_SIZE(inetsw_array)\n\n// inet_init()\n  sock_register(\ninet_family_ops);\n\n  /* Register the socket-side information for inet_create. */\n  for (struct list_head *r = \ninetsw[0]; r \n \ninetsw[SOCK_MAX]; ++r)\n    INIT_LIST_HEAD(r);\n\n  for (struct inet_protosw *q = inetsw_array; q \n \ninetsw_array[INETSW_ARRAY_LEN]; ++q)\n    inet_register_protosw(q);\n\n\n\n\nAfter Initialization:\n\n\n\nskbuff\n\n\nA sample of receive skb for TCP SYN segment:", 
            "title": "Data Structures"
        }, 
        {
            "location": "/kernel/data-structures/#net_proto_family", 
            "text": "// include/linux/net.h\n// How to create a socket for an address family\nstruct net_proto_family {\n  int family;  // AF_INET, AF_UNIX, AF_INET6, etc. must: 0  = family   NPROTO\n  int (*create)(struct net *net, struct socket *sock, int protocol, int kern);\n  struct module *owner;\n};  // net/socket.c\nstatic const struct net_proto_family *net_families[NPROTO];\n\n// net/ipv4/af_inet.c\nstatic int inet_create(struct net *net, struct socket *sock, int protocol, int kern);\n\nstatic const struct net_proto_family inet_family_ops = {\n  .family = PF_INET,\n  .create = inet_create,\n  .owner  = THIS_MODULE\n};\n\n// inet_init() calls sock_register():\nnet_families[AF_INET] =  inet_family_ops;  int sys_socket(int family, int type, int protocol)\n  -  struct socket* sock_create(family, type, protocol)\n    -  __sock_create(family, type, protocol)\n      -  struct socket* sock = sock_alloc()\n        -  new_inode_pseudo(super_block of sockfs)      // fs/inode.c\n      -  net_families[family]- create(sock, protocol)\n        -  inet_create(sock, protocol)                  // net/ipv4/af_inet.c\n  -  sock_map_fd()\n\ninet_create(sock, protocol)\n  -  find inet_protosw for sock- type   protocol\n  -  struct sock* sk = sk_alloc()\n    -  sk_prot_alloc -  kmem_cache_alloc (tcp_prot is 1296B)\n  -  sock_init_data\n  -  sk- sk_prot- init(sk)\n    -  tcp_v4_init_sock", 
            "title": "net_proto_family"
        }, 
        {
            "location": "/kernel/data-structures/#inet_protosw", 
            "text": "// include/net/protocol.h\n/* This is used to register socket interfaces for IP protocols.  */\nstruct inet_protosw {\n  struct list_head list;\n\n  /* These two fields form the lookup key.  */\n  unsigned short   type;     /* This is the 2nd argument to socket(2).  eg. SOCK_STREAM, SOCK_DGRAM */\n  unsigned short   protocol; /* This is the L4 protocol number.  eg. IPPROTO_TCP, IPPROTO_TCP */\n\n  struct proto           *prot;\n  const struct proto_ops *ops;\n\n  unsigned char    flags;      /* See INET_PROTOSW_* below.  */\n};\n#define INET_PROTOSW_REUSE      0x01  /* Are ports automatically reusable? */\n#define INET_PROTOSW_PERMANENT  0x02  /* Permanent protocols are unremovable. */\n#define INET_PROTOSW_ICSK       0x04  /* Is this an inet_connection_sock? */  // net/ipv4/af_inet.c\n/* The inetsw table contains everything that inet_create needs to\n * build a new socket.\n */\nstatic struct list_head inetsw[SOCK_MAX];\nstatic DEFINE_SPINLOCK(inetsw_lock);\n\n/* Upon startup we insert all the elements in inetsw_array[] into\n * the linked list inetsw.\n */\nstatic struct inet_protosw inetsw_array[] =\n{\n  {\n    .type =       SOCK_STREAM,\n    .protocol =   IPPROTO_TCP,\n    .prot =        tcp_prot,\n    .ops =         inet_stream_ops,\n    .flags =      INET_PROTOSW_PERMANENT | INET_PROTOSW_ICSK,\n  },\n  {\n    .type =       SOCK_DGRAM,\n    .protocol =   IPPROTO_UDP,\n    .prot =        udp_prot,\n    .ops =         inet_dgram_ops,\n    .flags =      INET_PROTOSW_PERMANENT,\n  },\n  {\n    .type =       SOCK_DGRAM,\n    .protocol =   IPPROTO_ICMP,\n    .prot =        ping_prot,\n    .ops =         inet_dgram_ops,\n    .flags =      INET_PROTOSW_REUSE,\n  },\n  {\n    .type =       SOCK_RAW,\n    .protocol =   IPPROTO_IP,        /* wild card */\n    .prot =        raw_prot,\n    .ops =         inet_sockraw_ops,\n    .flags =      INET_PROTOSW_REUSE,\n  }\n};\n\n#define INETSW_ARRAY_LEN ARRAY_SIZE(inetsw_array)\n\n// inet_init()\n  sock_register( inet_family_ops);\n\n  /* Register the socket-side information for inet_create. */\n  for (struct list_head *r =  inetsw[0]; r    inetsw[SOCK_MAX]; ++r)\n    INIT_LIST_HEAD(r);\n\n  for (struct inet_protosw *q = inetsw_array; q    inetsw_array[INETSW_ARRAY_LEN]; ++q)\n    inet_register_protosw(q);  After Initialization:", 
            "title": "inet_protosw"
        }, 
        {
            "location": "/kernel/data-structures/#skbuff", 
            "text": "A sample of receive skb for TCP SYN segment:", 
            "title": "skbuff"
        }, 
        {
            "location": "/kernel/callgraph/", 
            "text": "bind\n\n\nsys_bind\n  -\n inet_bind\n    -\n inet_csk_get_port\n      -\n goto have_snum:\n      -\n goto tb_not_found:  tb == NULL\n        -\n inet_bind_bucket_create\n      -\n goto success:\n        -\n inet_bind_hash\n          -\n sk_add_bind_node\n  -\n fput_light\n\n\n\n\nlisten\n\n\nsys_listen\n  -\n inet_listen\n    -\n inet_csk_listen_start\n      -\n reqsk_queue_alloc\n      -\n inet_csk_delack_init\n      -\n set sk-\nsk_state = TCP_LISTEN\n      -\n inet_csk_get_port\n        -\n goto have_snum:\n        -\n goto tb_found:\n          -\n inet_csk_bind_conflict\n        -\n goto tb_not_found:  tb != NULL\n      -\n inet_hash\n        -\n __inet_hash  // tcp_hashinfo.listening_hash[X] add node\n\n\n\n\n\n\nPassive open\n\n\nReceive SYN\n\n\ntcp_v4_rcv\n  -\n __inet_lookup_skb\n    -\n __inet_lookup\n      -\n __inet_lookup_established\n      -\n __inet_lookup_listener  // found\n\n  -\n tcp_v4_do_rcv  // sk_state == TCP_LISTEN\n    -\n tcp_rcv_state_process\n      -\n tcp_v4_conn_request  // icsk-\nicsk_af_ops-\nconn_request\n        -\n tcp_conn_request\n          -\n req = inet_reqsk_alloc\n            -\n reqsk_alloc\n               req-\nrsk_listener = sk_listener;\n            ireq-\nireq_state = TCP_NEW_SYN_RECV;\n          -\n tcp_parse_options\n          -\n tcp_openreq_init\n          -\n tcp_v4_init_req  // af_ops-\ninit_req\n            -\n tcp_v4_save_options\n          -\n tcp_v4_init_sequence  // af_ops-\ninit_seq\n          -\n tcp_v4_route_req  // af_ops-\nroute_req\n            -\n inet_csk_route_req\n              -\n flowi4_init_output\n              -\n ip_route_output_flow\n          -\n tcp_ecn_create_request\n          -\n tcp_reqsk_record_syn\n          -\n inet_csk_reqsk_queue_hash_add\n            -\n reqsk_queue_hash_req\n              -\n inet_ehash_insert\n                -\n __sk_nulls_add_node_rcu\n            -\n inet_csk_reqsk_queue_added\n          -\n tcp_v4_send_synack  // af_ops-\nsend_synack\n            -\n tcp_make_synack\n            -\n __tcp_v4_send_check\n            -\n ip_build_and_send_pkt\n              -\n ip_local_out\n                -\n __ip_local_out\n                  -\n dst_output\n                    -\n ip_output\n\n\n\n\nReceive ACK\n\n\ntcp_v4_rcv\n  -\n __inet_lookup_skb\n    -\n __inet_lookup\n      -\n __inet_lookup_established  // found\n  -\n sk-\nsk_state == TCP_NEW_SYN_RECV\n  -\n tcp_check_req\n    -\n tcp_parse_options\n      -\n tcp_paws_reject\n      -\n tcp_in_window\n    -\n tcp_v4_syn_recv_sock  // inet_csk(sk)-\nicsk_af_ops-\nsyn_recv_sock\n      -\n tcp_create_openreq_child\n        -\n inet_csk_clone_lock\n          -\n sk_clone_lock\n            -\n sk_prot_alloc\n        -\n tcp_init_xmit_timers\n      -\n inet_sk_rx_dst_set\n      -\n inet_csk_route_child_sock\n      -\n tcp_ca_openreq_child\n        -\n tcp_assign_congestion_control\n        -\n tcp_set_ca_state TCP_CA_Open\n          -\n bictcp_state\n      -\n tcp_sync_mss -\n dst_mtu -\n ipv4_mtu\n        -\n tcp_mtu_to_mss\n        -\n tcp_bound_to_half_wnd\n      -\n dst_metric_advmss -\n ipv4_default_advmss\n      -\n tcp_initialize_rcv_mss\n      -\n __inet_inherit_port -\n inet_bind_hash\n      -\n inet_ehash_nolisten\n        -\n inet_ehash_insert\n          -\n sk_nulls_del_node_init_rcu\n          -\n __sk_nulls_add_node_rcu\n        -\n sock_prot_inuse_add\n      -\n tcp_move_syn\n    -\n sock_rps_save_rxhash\n    -\n tcp_synack_rtt_meas\n      -\n skb_mstamp_us_delta\n      -\n tcp_ack_update_rtt\n        -\n tcp_update_rtt_min\n        -\n tcp_rtt_estimator\n        -\n tcp_set_rto\n    -\n inet_csk_complete_hashdance\n      -\n inet_csk_reqsk_queue_drop\n      -\n reqsk_queue_removed\n      -\n inet_csk_reqsk_queue_add\n        -\n sk_acceptq_added\n  -\n tcp_child_process\n    -\n tcp_rcv_state_process\n      -\n tcp_validate_incoming\n      -\n tcp_ack\n        -\n tcp_ack_update_window\n        -\n tcp_ecn_rcv_ecn_echo  // false\n        -\n tcp_in_ack_event\n        return 1\n      -\n sk_state == TCP_SYN_RECV\n      -\n inet_sk_rebuild_header  // icsk-\nicsk_af_ops-\nrebuild_header\n      -\n tcp_init_congestion_control -\n bictcp_init\n      -\n tcp_mtup_init\n      -\n tcp_init_buffer_space\n        -\n tcp_fixup_rcvbuf\n        -\n tcp_sndbuf_expand\n        -\n tcp_full_space\n      TCP_ESTABLISHED\n      sk-\nsk_state_change -\n sock_def_wakeup\n      -\n tcp_init_metrics\n      -\n tcp_update_pacing_rate\n      -\n tcp_initialize_rcv_mss\n      -\n tcp_fast_path_on\n      // out of switch\n      -\n tcp_urg\n      // switch TCP_ESTABLISHED\n      -\n tcp_data_queue\n      -\n tcp_data_snd_check\n      -\n tcp_ack_snd_check\n    -\n parent-\nsk_data_ready -\n sock_def_readable -\n wake_up_interruptible_sync_poll\n\n\n\n\nconnect\n\n\ntcp_v4_rcv\n\n\nread\n\n\nwrite", 
            "title": "Call Graphs"
        }, 
        {
            "location": "/kernel/callgraph/#bind", 
            "text": "sys_bind\n  -  inet_bind\n    -  inet_csk_get_port\n      -  goto have_snum:\n      -  goto tb_not_found:  tb == NULL\n        -  inet_bind_bucket_create\n      -  goto success:\n        -  inet_bind_hash\n          -  sk_add_bind_node\n  -  fput_light", 
            "title": "bind"
        }, 
        {
            "location": "/kernel/callgraph/#listen", 
            "text": "sys_listen\n  -  inet_listen\n    -  inet_csk_listen_start\n      -  reqsk_queue_alloc\n      -  inet_csk_delack_init\n      -  set sk- sk_state = TCP_LISTEN\n      -  inet_csk_get_port\n        -  goto have_snum:\n        -  goto tb_found:\n          -  inet_csk_bind_conflict\n        -  goto tb_not_found:  tb != NULL\n      -  inet_hash\n        -  __inet_hash  // tcp_hashinfo.listening_hash[X] add node", 
            "title": "listen"
        }, 
        {
            "location": "/kernel/callgraph/#passive-open", 
            "text": "", 
            "title": "Passive open"
        }, 
        {
            "location": "/kernel/callgraph/#receive-syn", 
            "text": "tcp_v4_rcv\n  -  __inet_lookup_skb\n    -  __inet_lookup\n      -  __inet_lookup_established\n      -  __inet_lookup_listener  // found\n\n  -  tcp_v4_do_rcv  // sk_state == TCP_LISTEN\n    -  tcp_rcv_state_process\n      -  tcp_v4_conn_request  // icsk- icsk_af_ops- conn_request\n        -  tcp_conn_request\n          -  req = inet_reqsk_alloc\n            -  reqsk_alloc\n               req- rsk_listener = sk_listener;\n            ireq- ireq_state = TCP_NEW_SYN_RECV;\n          -  tcp_parse_options\n          -  tcp_openreq_init\n          -  tcp_v4_init_req  // af_ops- init_req\n            -  tcp_v4_save_options\n          -  tcp_v4_init_sequence  // af_ops- init_seq\n          -  tcp_v4_route_req  // af_ops- route_req\n            -  inet_csk_route_req\n              -  flowi4_init_output\n              -  ip_route_output_flow\n          -  tcp_ecn_create_request\n          -  tcp_reqsk_record_syn\n          -  inet_csk_reqsk_queue_hash_add\n            -  reqsk_queue_hash_req\n              -  inet_ehash_insert\n                -  __sk_nulls_add_node_rcu\n            -  inet_csk_reqsk_queue_added\n          -  tcp_v4_send_synack  // af_ops- send_synack\n            -  tcp_make_synack\n            -  __tcp_v4_send_check\n            -  ip_build_and_send_pkt\n              -  ip_local_out\n                -  __ip_local_out\n                  -  dst_output\n                    -  ip_output", 
            "title": "Receive SYN"
        }, 
        {
            "location": "/kernel/callgraph/#receive-ack", 
            "text": "tcp_v4_rcv\n  -  __inet_lookup_skb\n    -  __inet_lookup\n      -  __inet_lookup_established  // found\n  -  sk- sk_state == TCP_NEW_SYN_RECV\n  -  tcp_check_req\n    -  tcp_parse_options\n      -  tcp_paws_reject\n      -  tcp_in_window\n    -  tcp_v4_syn_recv_sock  // inet_csk(sk)- icsk_af_ops- syn_recv_sock\n      -  tcp_create_openreq_child\n        -  inet_csk_clone_lock\n          -  sk_clone_lock\n            -  sk_prot_alloc\n        -  tcp_init_xmit_timers\n      -  inet_sk_rx_dst_set\n      -  inet_csk_route_child_sock\n      -  tcp_ca_openreq_child\n        -  tcp_assign_congestion_control\n        -  tcp_set_ca_state TCP_CA_Open\n          -  bictcp_state\n      -  tcp_sync_mss -  dst_mtu -  ipv4_mtu\n        -  tcp_mtu_to_mss\n        -  tcp_bound_to_half_wnd\n      -  dst_metric_advmss -  ipv4_default_advmss\n      -  tcp_initialize_rcv_mss\n      -  __inet_inherit_port -  inet_bind_hash\n      -  inet_ehash_nolisten\n        -  inet_ehash_insert\n          -  sk_nulls_del_node_init_rcu\n          -  __sk_nulls_add_node_rcu\n        -  sock_prot_inuse_add\n      -  tcp_move_syn\n    -  sock_rps_save_rxhash\n    -  tcp_synack_rtt_meas\n      -  skb_mstamp_us_delta\n      -  tcp_ack_update_rtt\n        -  tcp_update_rtt_min\n        -  tcp_rtt_estimator\n        -  tcp_set_rto\n    -  inet_csk_complete_hashdance\n      -  inet_csk_reqsk_queue_drop\n      -  reqsk_queue_removed\n      -  inet_csk_reqsk_queue_add\n        -  sk_acceptq_added\n  -  tcp_child_process\n    -  tcp_rcv_state_process\n      -  tcp_validate_incoming\n      -  tcp_ack\n        -  tcp_ack_update_window\n        -  tcp_ecn_rcv_ecn_echo  // false\n        -  tcp_in_ack_event\n        return 1\n      -  sk_state == TCP_SYN_RECV\n      -  inet_sk_rebuild_header  // icsk- icsk_af_ops- rebuild_header\n      -  tcp_init_congestion_control -  bictcp_init\n      -  tcp_mtup_init\n      -  tcp_init_buffer_space\n        -  tcp_fixup_rcvbuf\n        -  tcp_sndbuf_expand\n        -  tcp_full_space\n      TCP_ESTABLISHED\n      sk- sk_state_change -  sock_def_wakeup\n      -  tcp_init_metrics\n      -  tcp_update_pacing_rate\n      -  tcp_initialize_rcv_mss\n      -  tcp_fast_path_on\n      // out of switch\n      -  tcp_urg\n      // switch TCP_ESTABLISHED\n      -  tcp_data_queue\n      -  tcp_data_snd_check\n      -  tcp_ack_snd_check\n    -  parent- sk_data_ready -  sock_def_readable -  wake_up_interruptible_sync_poll", 
            "title": "Receive ACK"
        }, 
        {
            "location": "/kernel/callgraph/#connect", 
            "text": "", 
            "title": "connect"
        }, 
        {
            "location": "/kernel/callgraph/#tcp_v4_rcv", 
            "text": "", 
            "title": "tcp_v4_rcv"
        }, 
        {
            "location": "/kernel/callgraph/#read", 
            "text": "", 
            "title": "read"
        }, 
        {
            "location": "/kernel/callgraph/#write", 
            "text": "", 
            "title": "write"
        }, 
        {
            "location": "/lcc/", 
            "text": "Notes on LCC\n\n\nCallgraph of parsing expressions\n\n\n\n\nCallgraph of parsing statements\n\n\n\n\nCalltree of compiling an empty program\n\n\nCalltree of lcc 4.2\n for following simple program:\n\n\nint main()\n{\n  return 0;\n}", 
            "title": "lcc"
        }, 
        {
            "location": "/lcc/#notes-on-lcc", 
            "text": "", 
            "title": "Notes on LCC"
        }, 
        {
            "location": "/lcc/#callgraph-of-parsing-expressions", 
            "text": "", 
            "title": "Callgraph of parsing expressions"
        }, 
        {
            "location": "/lcc/#callgraph-of-parsing-statements", 
            "text": "", 
            "title": "Callgraph of parsing statements"
        }, 
        {
            "location": "/lcc/#calltree-of-compiling-an-empty-program", 
            "text": "Calltree of lcc 4.2  for following simple program:  int main()\n{\n  return 0;\n}", 
            "title": "Calltree of compiling an empty program"
        }, 
        {
            "location": "/lua/", 
            "text": "Notes on Lua implementation\n\n\nCalltree of Lua 5.3\n for following simple program:\n\n\nx = 10\nprint(x)", 
            "title": "Lua"
        }, 
        {
            "location": "/lua/#notes-on-lua-implementation", 
            "text": "Calltree of Lua 5.3  for following simple program:  x = 10\nprint(x)", 
            "title": "Notes on Lua implementation"
        }, 
        {
            "location": "/ssl/", 
            "text": "Notes on SSL/TLS\n\n\n\n\nRFC7539\n defines ChaCha20 and Poly1305\n\n\nRFC7905\n adds TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 (0xCCA8) etc to TLS 1.2\n\n\nThere is an old version of ECDHE_RSA_CHACHA20_POLY1305_OLD (0xCC13) exists in \ndraft\n and OpenSSL \ncode\n.\n\n\nOpenSSL will prefer AES if hardware supports it, otherwise prefer ChaCha20 over AES, in \nssl_create_cipher_list()\n.\n\n\nOpenSSL 1.1.0 provides \nSSL_SESSION_get_master_key()\n function.", 
            "title": "SSL"
        }, 
        {
            "location": "/ssl/#notes-on-ssltls", 
            "text": "RFC7539  defines ChaCha20 and Poly1305  RFC7905  adds TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 (0xCCA8) etc to TLS 1.2  There is an old version of ECDHE_RSA_CHACHA20_POLY1305_OLD (0xCC13) exists in  draft  and OpenSSL  code .  OpenSSL will prefer AES if hardware supports it, otherwise prefer ChaCha20 over AES, in  ssl_create_cipher_list() .  OpenSSL 1.1.0 provides  SSL_SESSION_get_master_key()  function.", 
            "title": "Notes on SSL/TLS"
        }
    ]
}