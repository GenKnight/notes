{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to MkDocs\n\n\nFor full documentation visit \nmkdocs.org\n.\n\n\nCommands\n\n\n\n\nmkdocs new [dir-name]\n - Create a new project.\n\n\nmkdocs serve\n - Start the live-reloading docs server.\n\n\nmkdocs build\n - Build the documentation site.\n\n\nmkdocs help\n - Print this help message.\n\n\n\n\nProject layout\n\n\nmkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-mkdocs", 
            "text": "For full documentation visit  mkdocs.org .", 
            "title": "Welcome to MkDocs"
        }, 
        {
            "location": "/#commands", 
            "text": "mkdocs new [dir-name]  - Create a new project.  mkdocs serve  - Start the live-reloading docs server.  mkdocs build  - Build the documentation site.  mkdocs help  - Print this help message.", 
            "title": "Commands"
        }, 
        {
            "location": "/#project-layout", 
            "text": "mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.", 
            "title": "Project layout"
        }, 
        {
            "location": "/bugs/", 
            "text": "Bugs\n\n\nGCC\n\n\nBug 54812\n: \nprivate\n \n=default\n destructor is \npublic\n\n\nDelete expression doesn't respect access of defaulted destructor\n\n\nstruct Base\n{\n private:\n  ~Base() = default;\n};\n\nint main()\n{\n  Base* p = new Base;\n  delete p;\n}\n\n\n\n\n\n\nQuote:\n The bug affects protected destructors too, and they're commonly used for base classes to prevent deletion via pointer-to-base.\n\n\n\n\nFixed in 4.9.0, by \nr203985\n.\nTest case added by \nr204057\n.\n\n\nGlibc\n\n\nstrstr(3)\n\n\nSince glibc 2.9, strstr(3) may use \nTwo Way algorithm\n in some cases, but the impl. had several bugs:\n\n\n\n\nBug 12092\n\n\nBug 12100\n\n\nBug 14602\n\n\nMore?", 
            "title": "Bugs"
        }, 
        {
            "location": "/bugs/#bugs", 
            "text": "", 
            "title": "Bugs"
        }, 
        {
            "location": "/bugs/#gcc", 
            "text": "", 
            "title": "GCC"
        }, 
        {
            "location": "/bugs/#bug-54812-private-default-destructor-is-public", 
            "text": "Delete expression doesn't respect access of defaulted destructor  struct Base\n{\n private:\n  ~Base() = default;\n};\n\nint main()\n{\n  Base* p = new Base;\n  delete p;\n}   Quote:  The bug affects protected destructors too, and they're commonly used for base classes to prevent deletion via pointer-to-base.   Fixed in 4.9.0, by  r203985 .\nTest case added by  r204057 .", 
            "title": "Bug 54812: private =default destructor is public"
        }, 
        {
            "location": "/bugs/#glibc", 
            "text": "", 
            "title": "Glibc"
        }, 
        {
            "location": "/bugs/#strstr3", 
            "text": "Since glibc 2.9, strstr(3) may use  Two Way algorithm  in some cases, but the impl. had several bugs:   Bug 12092  Bug 12100  Bug 14602  More?", 
            "title": "strstr(3)"
        }, 
        {
            "location": "/git/", 
            "text": "Notes on Git\n\n\nData model\n\n\n\n\nblob\n is content of file\n\n\n\n\n$ git cat-file -p 74576250e3c3a901bf06832bd0e4ee5e00422115\n# Shuo's notes\nhttp://chenshuo.github.io/notes\n\n\n\n\n\n\ntree\n has one or more \ntree\n/\nblob\n, it's \nMerkle tree\n.\n\n\nblob\n are leaf nodes\n\n\ntree\n are internal nodes\n\n\n\n\n\n\n\n\n$ git cat-file -p 5d42664e3d812288b47795718d0e4faf26397bf9\n100644 blob cde88fe0e10f265ed3cb2af0ea5422f607c1a37c    .gitignore\n100644 blob 74576250e3c3a901bf06832bd0e4ee5e00422115    README.md\n040000 tree eabff4ee0b30f5d6a644ce508ba7fe47dc563aa4    docs\n100644 blob 020682e2399c75cf3ad9636964c7501f27a0e893    mkdocs.yml\n\n\n\n\n\n\ncommit\n:\n\n\nhas one \ntree\n\n\nhas one or more parent \ncommit\n(s)\n\n\n\n\n\n\n\n\n$ git cat-file -p 3f08891b366c750d4739241874cfb1dbef56c398\ntree 5d42664e3d812288b47795718d0e4faf26397bf9\nparent 955f683cae5d2514d1c788fce9206451e2ac3334\nauthor Shuo Chen \nchenshuo@chenshuo.com\n 1484903215 -0800\ncommitter Shuo Chen \nchenshuo@chenshuo.com\n 1484903215 -0800\n\nupdate ssl.md\n\n\n\n\n\n\n\n\ntag\n ???\n\n\n\n\n\n\nExceptions:\n\n\n\n\ninitial \ncommit\n has no parent\n\n\nempty file is empty \nblob\n\n\nempty directory is empty \ntree\n\n\n\n\n\n\n\n\nPack file format\n\n\nDelta\n\n\nPack index format", 
            "title": "Git"
        }, 
        {
            "location": "/git/#notes-on-git", 
            "text": "", 
            "title": "Notes on Git"
        }, 
        {
            "location": "/git/#data-model", 
            "text": "blob  is content of file   $ git cat-file -p 74576250e3c3a901bf06832bd0e4ee5e00422115\n# Shuo's notes\nhttp://chenshuo.github.io/notes   tree  has one or more  tree / blob , it's  Merkle tree .  blob  are leaf nodes  tree  are internal nodes     $ git cat-file -p 5d42664e3d812288b47795718d0e4faf26397bf9\n100644 blob cde88fe0e10f265ed3cb2af0ea5422f607c1a37c    .gitignore\n100644 blob 74576250e3c3a901bf06832bd0e4ee5e00422115    README.md\n040000 tree eabff4ee0b30f5d6a644ce508ba7fe47dc563aa4    docs\n100644 blob 020682e2399c75cf3ad9636964c7501f27a0e893    mkdocs.yml   commit :  has one  tree  has one or more parent  commit (s)     $ git cat-file -p 3f08891b366c750d4739241874cfb1dbef56c398\ntree 5d42664e3d812288b47795718d0e4faf26397bf9\nparent 955f683cae5d2514d1c788fce9206451e2ac3334\nauthor Shuo Chen  chenshuo@chenshuo.com  1484903215 -0800\ncommitter Shuo Chen  chenshuo@chenshuo.com  1484903215 -0800\n\nupdate ssl.md    tag  ???    Exceptions:   initial  commit  has no parent  empty file is empty  blob  empty directory is empty  tree", 
            "title": "Data model"
        }, 
        {
            "location": "/git/#pack-file-format", 
            "text": "", 
            "title": "Pack file format"
        }, 
        {
            "location": "/git/#delta", 
            "text": "", 
            "title": "Delta"
        }, 
        {
            "location": "/git/#pack-index-format", 
            "text": "", 
            "title": "Pack index format"
        }, 
        {
            "location": "/kernel/data-structures/", 
            "text": "family\n\n\ntype\n\n\nprotocol\n\n\n\n\n\n\n\n\n\n\nAF_UNIX=1\n\n\nSOCK_STREAM=1\n\n\n0\n\n\n\n\n\n\nAF_UNIX\n\n\nSOCK_DGRAM=2\n\n\n0\n\n\n\n\n\n\nAF_INET=2\n\n\nSOCK_STREAM\n\n\nIPPROTO_TCP=6\n\n\n\n\n\n\nAF_INET\n\n\nSOCK_DGRAM\n\n\nIPPROTO_UDP=17\n\n\n\n\n\n\nAF_INET\n\n\nSOCK_DGRAM\n\n\nIPPROTO_ICMP=1\n\n\n\n\n\n\nAF_INET\n\n\nSOCK_RAW=3\n\n\nIPPROTO_IP=0\n\n\n\n\n\n\nNPROTO=AF_MAX=41\n\n\nSOCK_MAX=11\n\n\nno max?\n\n\n\n\n\n\n\n\nnet_proto_family\n\n\n// include/linux/net.h\n// How to create a socket for an address family\nstruct net_proto_family {\n  int family;  // AF_INET, AF_UNIX, AF_INET6, etc. must: 0 \n= family \n NPROTO\n  int (*create)(struct net *net, struct socket *sock, int protocol, int kern);\n  struct module *owner;\n};\n\n\n\n\n\n// net/socket.c\nstatic const struct net_proto_family *net_families[NPROTO];\n\n// net/ipv4/af_inet.c\nstatic int inet_create(struct net *net, struct socket *sock, int protocol, int kern);\n\nstatic const struct net_proto_family inet_family_ops = {\n  .family = PF_INET,\n  .create = inet_create,\n  .owner  = THIS_MODULE\n};\n\n// inet_init() calls sock_register():\nnet_families[AF_INET] = \ninet_family_ops;\n\n\n\n\nint sys_socket(int family, int type, int protocol)\n  -\n struct socket* sock_create(family, type, protocol)\n    -\n __sock_create(family, type, protocol)\n      -\n struct socket* sock = sock_alloc()\n        -\n new_inode_pseudo(super_block of sockfs)      // fs/inode.c\n      -\n net_families[family]-\ncreate(sock, protocol)\n        -\n inet_create(sock, protocol)                  // net/ipv4/af_inet.c\n  -\n sock_map_fd()\n\ninet_create(sock, protocol)\n  -\n find inet_protosw for sock-\ntype \n protocol\n  -\n struct sock* sk = sk_alloc()\n    -\n sk_prot_alloc -\n kmem_cache_alloc (tcp_prot is 1296B)\n  -\n sock_init_data\n  -\n sk-\nsk_prot-\ninit(sk)\n    -\n tcp_v4_init_sock\n\n\n\n\ninet_protosw\n\n\n// include/net/protocol.h\n/* This is used to register socket interfaces for IP protocols.  */\nstruct inet_protosw {\n  struct list_head list;\n\n  /* These two fields form the lookup key.  */\n  unsigned short   type;     /* This is the 2nd argument to socket(2).  eg. SOCK_STREAM, SOCK_DGRAM */\n  unsigned short   protocol; /* This is the L4 protocol number.  eg. IPPROTO_TCP, IPPROTO_TCP */\n\n  struct proto           *prot;\n  const struct proto_ops *ops;\n\n  unsigned char    flags;      /* See INET_PROTOSW_* below.  */\n};\n#define INET_PROTOSW_REUSE      0x01  /* Are ports automatically reusable? */\n#define INET_PROTOSW_PERMANENT  0x02  /* Permanent protocols are unremovable. */\n#define INET_PROTOSW_ICSK       0x04  /* Is this an inet_connection_sock? */\n\n\n\n\n// net/ipv4/af_inet.c\n/* The inetsw table contains everything that inet_create needs to\n * build a new socket.\n */\nstatic struct list_head inetsw[SOCK_MAX];\nstatic DEFINE_SPINLOCK(inetsw_lock);\n\n/* Upon startup we insert all the elements in inetsw_array[] into\n * the linked list inetsw.\n */\nstatic struct inet_protosw inetsw_array[] =\n{\n  {\n    .type =       SOCK_STREAM,\n    .protocol =   IPPROTO_TCP,\n    .prot =       \ntcp_prot,\n    .ops =        \ninet_stream_ops,\n    .flags =      INET_PROTOSW_PERMANENT | INET_PROTOSW_ICSK,\n  },\n  {\n    .type =       SOCK_DGRAM,\n    .protocol =   IPPROTO_UDP,\n    .prot =       \nudp_prot,\n    .ops =        \ninet_dgram_ops,\n    .flags =      INET_PROTOSW_PERMANENT,\n  },\n  {\n    .type =       SOCK_DGRAM,\n    .protocol =   IPPROTO_ICMP,\n    .prot =       \nping_prot,\n    .ops =        \ninet_dgram_ops,\n    .flags =      INET_PROTOSW_REUSE,\n  },\n  {\n    .type =       SOCK_RAW,\n    .protocol =   IPPROTO_IP,        /* wild card */\n    .prot =       \nraw_prot,\n    .ops =        \ninet_sockraw_ops,\n    .flags =      INET_PROTOSW_REUSE,\n  }\n};\n\n#define INETSW_ARRAY_LEN ARRAY_SIZE(inetsw_array)\n\n// inet_init()\n  sock_register(\ninet_family_ops);\n\n  /* Register the socket-side information for inet_create. */\n  for (struct list_head *r = \ninetsw[0]; r \n \ninetsw[SOCK_MAX]; ++r)\n    INIT_LIST_HEAD(r);\n\n  for (struct inet_protosw *q = inetsw_array; q \n \ninetsw_array[INETSW_ARRAY_LEN]; ++q)\n    inet_register_protosw(q);\n\n\n\n\nAfter Initialization:\n\n\n\nskbuff\n\n\nA sample of receive skb for TCP SYN segment:", 
            "title": "Data Structures"
        }, 
        {
            "location": "/kernel/data-structures/#net_proto_family", 
            "text": "// include/linux/net.h\n// How to create a socket for an address family\nstruct net_proto_family {\n  int family;  // AF_INET, AF_UNIX, AF_INET6, etc. must: 0  = family   NPROTO\n  int (*create)(struct net *net, struct socket *sock, int protocol, int kern);\n  struct module *owner;\n};  // net/socket.c\nstatic const struct net_proto_family *net_families[NPROTO];\n\n// net/ipv4/af_inet.c\nstatic int inet_create(struct net *net, struct socket *sock, int protocol, int kern);\n\nstatic const struct net_proto_family inet_family_ops = {\n  .family = PF_INET,\n  .create = inet_create,\n  .owner  = THIS_MODULE\n};\n\n// inet_init() calls sock_register():\nnet_families[AF_INET] =  inet_family_ops;  int sys_socket(int family, int type, int protocol)\n  -  struct socket* sock_create(family, type, protocol)\n    -  __sock_create(family, type, protocol)\n      -  struct socket* sock = sock_alloc()\n        -  new_inode_pseudo(super_block of sockfs)      // fs/inode.c\n      -  net_families[family]- create(sock, protocol)\n        -  inet_create(sock, protocol)                  // net/ipv4/af_inet.c\n  -  sock_map_fd()\n\ninet_create(sock, protocol)\n  -  find inet_protosw for sock- type   protocol\n  -  struct sock* sk = sk_alloc()\n    -  sk_prot_alloc -  kmem_cache_alloc (tcp_prot is 1296B)\n  -  sock_init_data\n  -  sk- sk_prot- init(sk)\n    -  tcp_v4_init_sock", 
            "title": "net_proto_family"
        }, 
        {
            "location": "/kernel/data-structures/#inet_protosw", 
            "text": "// include/net/protocol.h\n/* This is used to register socket interfaces for IP protocols.  */\nstruct inet_protosw {\n  struct list_head list;\n\n  /* These two fields form the lookup key.  */\n  unsigned short   type;     /* This is the 2nd argument to socket(2).  eg. SOCK_STREAM, SOCK_DGRAM */\n  unsigned short   protocol; /* This is the L4 protocol number.  eg. IPPROTO_TCP, IPPROTO_TCP */\n\n  struct proto           *prot;\n  const struct proto_ops *ops;\n\n  unsigned char    flags;      /* See INET_PROTOSW_* below.  */\n};\n#define INET_PROTOSW_REUSE      0x01  /* Are ports automatically reusable? */\n#define INET_PROTOSW_PERMANENT  0x02  /* Permanent protocols are unremovable. */\n#define INET_PROTOSW_ICSK       0x04  /* Is this an inet_connection_sock? */  // net/ipv4/af_inet.c\n/* The inetsw table contains everything that inet_create needs to\n * build a new socket.\n */\nstatic struct list_head inetsw[SOCK_MAX];\nstatic DEFINE_SPINLOCK(inetsw_lock);\n\n/* Upon startup we insert all the elements in inetsw_array[] into\n * the linked list inetsw.\n */\nstatic struct inet_protosw inetsw_array[] =\n{\n  {\n    .type =       SOCK_STREAM,\n    .protocol =   IPPROTO_TCP,\n    .prot =        tcp_prot,\n    .ops =         inet_stream_ops,\n    .flags =      INET_PROTOSW_PERMANENT | INET_PROTOSW_ICSK,\n  },\n  {\n    .type =       SOCK_DGRAM,\n    .protocol =   IPPROTO_UDP,\n    .prot =        udp_prot,\n    .ops =         inet_dgram_ops,\n    .flags =      INET_PROTOSW_PERMANENT,\n  },\n  {\n    .type =       SOCK_DGRAM,\n    .protocol =   IPPROTO_ICMP,\n    .prot =        ping_prot,\n    .ops =         inet_dgram_ops,\n    .flags =      INET_PROTOSW_REUSE,\n  },\n  {\n    .type =       SOCK_RAW,\n    .protocol =   IPPROTO_IP,        /* wild card */\n    .prot =        raw_prot,\n    .ops =         inet_sockraw_ops,\n    .flags =      INET_PROTOSW_REUSE,\n  }\n};\n\n#define INETSW_ARRAY_LEN ARRAY_SIZE(inetsw_array)\n\n// inet_init()\n  sock_register( inet_family_ops);\n\n  /* Register the socket-side information for inet_create. */\n  for (struct list_head *r =  inetsw[0]; r    inetsw[SOCK_MAX]; ++r)\n    INIT_LIST_HEAD(r);\n\n  for (struct inet_protosw *q = inetsw_array; q    inetsw_array[INETSW_ARRAY_LEN]; ++q)\n    inet_register_protosw(q);  After Initialization:", 
            "title": "inet_protosw"
        }, 
        {
            "location": "/kernel/data-structures/#skbuff", 
            "text": "A sample of receive skb for TCP SYN segment:", 
            "title": "skbuff"
        }, 
        {
            "location": "/kernel/callgraph/", 
            "text": "bind\n\n\nsys_bind\n  -\n inet_bind\n    -\n inet_csk_get_port\n      -\n goto have_snum:\n      -\n goto tb_not_found:  tb == NULL\n        -\n inet_bind_bucket_create\n      -\n goto success:\n        -\n inet_bind_hash\n          -\n sk_add_bind_node\n  -\n fput_light\n\n\n\n\nlisten\n\n\nsys_listen\n  -\n inet_listen\n    -\n inet_csk_listen_start\n      -\n reqsk_queue_alloc\n      -\n inet_csk_delack_init\n      -\n set sk-\nsk_state = TCP_LISTEN\n      -\n inet_csk_get_port\n        -\n goto have_snum:\n        -\n goto tb_found:\n          -\n inet_csk_bind_conflict\n        -\n goto tb_not_found:  tb != NULL\n      -\n inet_hash\n        -\n __inet_hash  // tcp_hashinfo.listening_hash[X] add node\n\n\n\n\n\n\nPassive open\n\n\nReceive SYN\n\n\ntcp_v4_rcv\n  -\n __inet_lookup_skb\n    -\n __inet_lookup\n      -\n __inet_lookup_established\n      -\n __inet_lookup_listener  // found\n\n  -\n tcp_v4_do_rcv  // sk_state == TCP_LISTEN\n    -\n tcp_rcv_state_process\n      -\n tcp_v4_conn_request  // icsk-\nicsk_af_ops-\nconn_request\n        -\n tcp_conn_request\n          -\n req = inet_reqsk_alloc\n            -\n reqsk_alloc\n               req-\nrsk_listener = sk_listener;\n            ireq-\nireq_state = TCP_NEW_SYN_RECV;\n          -\n tcp_parse_options\n          -\n tcp_openreq_init\n          -\n tcp_v4_init_req  // af_ops-\ninit_req\n            -\n tcp_v4_save_options\n          -\n tcp_v4_init_sequence  // af_ops-\ninit_seq\n          -\n tcp_v4_route_req  // af_ops-\nroute_req\n            -\n inet_csk_route_req\n              -\n flowi4_init_output\n              -\n ip_route_output_flow\n          -\n tcp_ecn_create_request\n          -\n tcp_reqsk_record_syn\n          -\n inet_csk_reqsk_queue_hash_add\n            -\n reqsk_queue_hash_req\n              -\n inet_ehash_insert\n                -\n __sk_nulls_add_node_rcu\n            -\n inet_csk_reqsk_queue_added\n          -\n tcp_v4_send_synack  // af_ops-\nsend_synack\n            -\n tcp_make_synack\n            -\n __tcp_v4_send_check\n            -\n ip_build_and_send_pkt\n              -\n ip_local_out\n                -\n __ip_local_out\n                  -\n dst_output\n                    -\n ip_output\n\n\n\n\nReceive ACK\n\n\ntcp_v4_rcv\n  -\n __inet_lookup_skb\n    -\n __inet_lookup\n      -\n __inet_lookup_established  // found\n  -\n sk-\nsk_state == TCP_NEW_SYN_RECV\n  -\n tcp_check_req\n    -\n tcp_parse_options\n      -\n tcp_paws_reject\n      -\n tcp_in_window\n    -\n tcp_v4_syn_recv_sock  // inet_csk(sk)-\nicsk_af_ops-\nsyn_recv_sock\n      -\n tcp_create_openreq_child\n        -\n inet_csk_clone_lock\n          -\n sk_clone_lock\n            -\n sk_prot_alloc\n        -\n tcp_init_xmit_timers\n      -\n inet_sk_rx_dst_set\n      -\n inet_csk_route_child_sock\n      -\n tcp_ca_openreq_child\n        -\n tcp_assign_congestion_control\n        -\n tcp_set_ca_state TCP_CA_Open\n          -\n bictcp_state\n      -\n tcp_sync_mss -\n dst_mtu -\n ipv4_mtu\n        -\n tcp_mtu_to_mss\n        -\n tcp_bound_to_half_wnd\n      -\n dst_metric_advmss -\n ipv4_default_advmss\n      -\n tcp_initialize_rcv_mss\n      -\n __inet_inherit_port -\n inet_bind_hash\n      -\n inet_ehash_nolisten\n        -\n inet_ehash_insert\n          -\n sk_nulls_del_node_init_rcu\n          -\n __sk_nulls_add_node_rcu\n        -\n sock_prot_inuse_add\n      -\n tcp_move_syn\n    -\n sock_rps_save_rxhash\n    -\n tcp_synack_rtt_meas\n      -\n skb_mstamp_us_delta\n      -\n tcp_ack_update_rtt\n        -\n tcp_update_rtt_min\n        -\n tcp_rtt_estimator\n        -\n tcp_set_rto\n    -\n inet_csk_complete_hashdance\n      -\n inet_csk_reqsk_queue_drop\n      -\n reqsk_queue_removed\n      -\n inet_csk_reqsk_queue_add\n        -\n sk_acceptq_added\n  -\n tcp_child_process\n    -\n tcp_rcv_state_process\n      -\n tcp_validate_incoming\n      -\n tcp_ack\n        -\n tcp_ack_update_window\n        -\n tcp_ecn_rcv_ecn_echo  // false\n        -\n tcp_in_ack_event\n        return 1\n      -\n sk_state == TCP_SYN_RECV\n      -\n inet_sk_rebuild_header  // icsk-\nicsk_af_ops-\nrebuild_header\n      -\n tcp_init_congestion_control -\n bictcp_init\n      -\n tcp_mtup_init\n      -\n tcp_init_buffer_space\n        -\n tcp_fixup_rcvbuf\n        -\n tcp_sndbuf_expand\n        -\n tcp_full_space\n      TCP_ESTABLISHED\n      sk-\nsk_state_change -\n sock_def_wakeup\n      -\n tcp_init_metrics\n      -\n tcp_update_pacing_rate\n      -\n tcp_initialize_rcv_mss\n      -\n tcp_fast_path_on\n      // out of switch\n      -\n tcp_urg\n      // switch TCP_ESTABLISHED\n      -\n tcp_data_queue\n      -\n tcp_data_snd_check\n      -\n tcp_ack_snd_check\n    -\n parent-\nsk_data_ready -\n sock_def_readable -\n wake_up_interruptible_sync_poll\n\n\n\n\nActive open\n\n\nconnect\n\n\nsys_connect\n  -\n inet_stream_connect -\n __inet_stream_connect\n    -\n tcp_v4_connect (sk-\nsk_prot-\nconnect)\n      -\n ip_route_connect\n      tcp_set_state(sk, TCP_SYN_SENT)\n      -\n inet_hash_connect\n        -\n port_offset = inet_sk_port_offset(sk)\n          -\n secure_ipv4_port_ephemeral(saddr, daddr, dport)\n            -\n md5_transform\n        -\n __inet_hash_connect(..., port_offset, __inet_check_established)\n          static uint32_t hint // counter\n          -\n inet_get_local_port_range\n          -\n inet_bind_bucket_create\n          -\n inet_bind_hash\n            -\n sk_add_bind_node\n          -\n inet_ehash_nolisten\n            -\n inet_ehash_insert\n            -\n sock_prot_inuse_add\n      -\n ip_route_newports\n        -\n ip_route_output_flow\n      -\n secure_tcp_sequence_number(saddr, daddr, sport, dport)\n        -\n md5_transform\n      -\n tcp_connect\n        -\n tcp_connect_init\n        -\n sk_stream_alloc_skb\n        -\n tcp_init_nondata_skb\n        -\n tcp_connect_queue_skb\n        -\n tcp_ecn_send_syn\n        -\n tcp_transmit_skb\n          -\n tcp_options_size = tcp_syn_options\n          tcp_header_size = tcp_options_size + sizeof(struct tcphdr);\n          -\n skb_push(skb, tcp_header_size)\n          -\n skb_reset_transport_header\n          -\n skb_orphan\n          skb-\ndestructor = tcp_wfree;\n          -\n tcp_options_write\n          -\n tcp_v4_send_check (icsk-\nicsk_af_ops-\nsend_check)\n            -\n __tcp_v4_send_check\n              skb-\nip_summed == CHECKSUM_PARTIAL\n          -\n ip_queue_xmit (icsk-\nicsk_af_ops-\nqueue_xmit)\n            -\n skb_push\n            -\n skb_reset_network_header\n            iph-\nfrag_off = htons(IP_DF);\n            -\n ip_copy_addrs\n            -\n ip_select_ident_segs\n            -\n ip_local_out\n              -\n __ip_local_out\n                -\n ip_send_check\n                  -\n ip_fast_csum\n                -\n nf_hook { return 1; }\n              -\n dst_output\n                -\n ip_output (skb_dst(skb)-\noutput)\n        -\n inet_csk_reset_xmit_timer\n    sock-\nstate = SS_CONNECTING;\n    err = -EINPROGRESS;\n    timeo = sock_sndtimeo() // NULL\n    return err\n\n\n\n\nFIXME: add a diagram after \nconnect()\n\n\nReceive SYN+ACK\n\n\ntcp_v4_rcv\n  -\n __inet_lookup_skb\n    -\n __inet_lookup\n      -\n __inet_lookup_established  // found\n  -\n tcp_v4_do_rcv  // sk_state == TCP_SYN_SENT\n    -\n tcp_rcv_state_process\n      case TCP_SYN_SENT:\n      -\n tcp_rcv_synsent_state_process\n        -\n tcp_parse_options\n        if (th-\nack)  // true\n        -\n tcp_ecn_rcv_synack\n        -\n tcp_init_wl\n        -\n tcp_ack(FLAG_SLOWPATH)\n          // FLAG_SLOWPATH\n          -\n tcp_ack_update_window\n            -\n tcp_may_update_window  // true\n            -\n tcp_update_wln\n            -\n tcp_fast_path_check\n            -\n tcp_sync_mss\n            -\n tcp_snd_una_update\n          -\n tcp_ecn_rcv_ecn_echo  // false\n          -\n tcp_in_ack_event\n          -\n tcp_clean_rtx_queue\n            -\n tcp_ack_update_rtt\n            -\n tcp_rearm_rto\n          -\n tcp_rate_gen\n          -\n tcp_cong_control\n          -\n tcp_xmit_recovery\n        -\n tcp_mtup_init\n        -\n tcp_sync_mss\n        -\n tcp_initialize_rcv_mss\n        -\n tcp_finish_connect\n          -\n tcp_set_state(sk, TCP_ESTABLISHED);\n          -\n inet_sk_rx_dst_set (icsk-\nicsk_af_ops-\nsk_rx_dst_set)\n          -\n inet_sk_rebuild_header (icsk-\nicsk_af_ops-\nrebuild_header)\n          -\n tcp_init_metrics\n          -\n tcp_init_congestion_control\n          -\n tcp_init_buffer_space\n            -\n tcp_fixup_rcvbuf\n            -\n tcp_sndbuf_expand\n            -\n tcp_full_space\n        -\n tcp_send_ack\n          -\n skb_reserve\n          -\n tcp_init_nondata_skb\n          -\n skb_set_tcp_pure_ack\n          -\n skb_mstamp_get\n          -\n tcp_transmit_skb\n            -\n tcp_options_size = tcp_established_options  // 12\n            ...\n      -\n tcp_urg\n      -\n __kfree_skb\n      -\n tcp_data_snd_check\n      return 0;\n\n\n\n\nread\n\n\nwrite", 
            "title": "Call Graphs"
        }, 
        {
            "location": "/kernel/callgraph/#bind", 
            "text": "sys_bind\n  -  inet_bind\n    -  inet_csk_get_port\n      -  goto have_snum:\n      -  goto tb_not_found:  tb == NULL\n        -  inet_bind_bucket_create\n      -  goto success:\n        -  inet_bind_hash\n          -  sk_add_bind_node\n  -  fput_light", 
            "title": "bind"
        }, 
        {
            "location": "/kernel/callgraph/#listen", 
            "text": "sys_listen\n  -  inet_listen\n    -  inet_csk_listen_start\n      -  reqsk_queue_alloc\n      -  inet_csk_delack_init\n      -  set sk- sk_state = TCP_LISTEN\n      -  inet_csk_get_port\n        -  goto have_snum:\n        -  goto tb_found:\n          -  inet_csk_bind_conflict\n        -  goto tb_not_found:  tb != NULL\n      -  inet_hash\n        -  __inet_hash  // tcp_hashinfo.listening_hash[X] add node", 
            "title": "listen"
        }, 
        {
            "location": "/kernel/callgraph/#passive-open", 
            "text": "", 
            "title": "Passive open"
        }, 
        {
            "location": "/kernel/callgraph/#receive-syn", 
            "text": "tcp_v4_rcv\n  -  __inet_lookup_skb\n    -  __inet_lookup\n      -  __inet_lookup_established\n      -  __inet_lookup_listener  // found\n\n  -  tcp_v4_do_rcv  // sk_state == TCP_LISTEN\n    -  tcp_rcv_state_process\n      -  tcp_v4_conn_request  // icsk- icsk_af_ops- conn_request\n        -  tcp_conn_request\n          -  req = inet_reqsk_alloc\n            -  reqsk_alloc\n               req- rsk_listener = sk_listener;\n            ireq- ireq_state = TCP_NEW_SYN_RECV;\n          -  tcp_parse_options\n          -  tcp_openreq_init\n          -  tcp_v4_init_req  // af_ops- init_req\n            -  tcp_v4_save_options\n          -  tcp_v4_init_sequence  // af_ops- init_seq\n          -  tcp_v4_route_req  // af_ops- route_req\n            -  inet_csk_route_req\n              -  flowi4_init_output\n              -  ip_route_output_flow\n          -  tcp_ecn_create_request\n          -  tcp_reqsk_record_syn\n          -  inet_csk_reqsk_queue_hash_add\n            -  reqsk_queue_hash_req\n              -  inet_ehash_insert\n                -  __sk_nulls_add_node_rcu\n            -  inet_csk_reqsk_queue_added\n          -  tcp_v4_send_synack  // af_ops- send_synack\n            -  tcp_make_synack\n            -  __tcp_v4_send_check\n            -  ip_build_and_send_pkt\n              -  ip_local_out\n                -  __ip_local_out\n                  -  dst_output\n                    -  ip_output", 
            "title": "Receive SYN"
        }, 
        {
            "location": "/kernel/callgraph/#receive-ack", 
            "text": "tcp_v4_rcv\n  -  __inet_lookup_skb\n    -  __inet_lookup\n      -  __inet_lookup_established  // found\n  -  sk- sk_state == TCP_NEW_SYN_RECV\n  -  tcp_check_req\n    -  tcp_parse_options\n      -  tcp_paws_reject\n      -  tcp_in_window\n    -  tcp_v4_syn_recv_sock  // inet_csk(sk)- icsk_af_ops- syn_recv_sock\n      -  tcp_create_openreq_child\n        -  inet_csk_clone_lock\n          -  sk_clone_lock\n            -  sk_prot_alloc\n        -  tcp_init_xmit_timers\n      -  inet_sk_rx_dst_set\n      -  inet_csk_route_child_sock\n      -  tcp_ca_openreq_child\n        -  tcp_assign_congestion_control\n        -  tcp_set_ca_state TCP_CA_Open\n          -  bictcp_state\n      -  tcp_sync_mss -  dst_mtu -  ipv4_mtu\n        -  tcp_mtu_to_mss\n        -  tcp_bound_to_half_wnd\n      -  dst_metric_advmss -  ipv4_default_advmss\n      -  tcp_initialize_rcv_mss\n      -  __inet_inherit_port -  inet_bind_hash\n      -  inet_ehash_nolisten\n        -  inet_ehash_insert\n          -  sk_nulls_del_node_init_rcu\n          -  __sk_nulls_add_node_rcu\n        -  sock_prot_inuse_add\n      -  tcp_move_syn\n    -  sock_rps_save_rxhash\n    -  tcp_synack_rtt_meas\n      -  skb_mstamp_us_delta\n      -  tcp_ack_update_rtt\n        -  tcp_update_rtt_min\n        -  tcp_rtt_estimator\n        -  tcp_set_rto\n    -  inet_csk_complete_hashdance\n      -  inet_csk_reqsk_queue_drop\n      -  reqsk_queue_removed\n      -  inet_csk_reqsk_queue_add\n        -  sk_acceptq_added\n  -  tcp_child_process\n    -  tcp_rcv_state_process\n      -  tcp_validate_incoming\n      -  tcp_ack\n        -  tcp_ack_update_window\n        -  tcp_ecn_rcv_ecn_echo  // false\n        -  tcp_in_ack_event\n        return 1\n      -  sk_state == TCP_SYN_RECV\n      -  inet_sk_rebuild_header  // icsk- icsk_af_ops- rebuild_header\n      -  tcp_init_congestion_control -  bictcp_init\n      -  tcp_mtup_init\n      -  tcp_init_buffer_space\n        -  tcp_fixup_rcvbuf\n        -  tcp_sndbuf_expand\n        -  tcp_full_space\n      TCP_ESTABLISHED\n      sk- sk_state_change -  sock_def_wakeup\n      -  tcp_init_metrics\n      -  tcp_update_pacing_rate\n      -  tcp_initialize_rcv_mss\n      -  tcp_fast_path_on\n      // out of switch\n      -  tcp_urg\n      // switch TCP_ESTABLISHED\n      -  tcp_data_queue\n      -  tcp_data_snd_check\n      -  tcp_ack_snd_check\n    -  parent- sk_data_ready -  sock_def_readable -  wake_up_interruptible_sync_poll", 
            "title": "Receive ACK"
        }, 
        {
            "location": "/kernel/callgraph/#active-open", 
            "text": "", 
            "title": "Active open"
        }, 
        {
            "location": "/kernel/callgraph/#connect", 
            "text": "sys_connect\n  -  inet_stream_connect -  __inet_stream_connect\n    -  tcp_v4_connect (sk- sk_prot- connect)\n      -  ip_route_connect\n      tcp_set_state(sk, TCP_SYN_SENT)\n      -  inet_hash_connect\n        -  port_offset = inet_sk_port_offset(sk)\n          -  secure_ipv4_port_ephemeral(saddr, daddr, dport)\n            -  md5_transform\n        -  __inet_hash_connect(..., port_offset, __inet_check_established)\n          static uint32_t hint // counter\n          -  inet_get_local_port_range\n          -  inet_bind_bucket_create\n          -  inet_bind_hash\n            -  sk_add_bind_node\n          -  inet_ehash_nolisten\n            -  inet_ehash_insert\n            -  sock_prot_inuse_add\n      -  ip_route_newports\n        -  ip_route_output_flow\n      -  secure_tcp_sequence_number(saddr, daddr, sport, dport)\n        -  md5_transform\n      -  tcp_connect\n        -  tcp_connect_init\n        -  sk_stream_alloc_skb\n        -  tcp_init_nondata_skb\n        -  tcp_connect_queue_skb\n        -  tcp_ecn_send_syn\n        -  tcp_transmit_skb\n          -  tcp_options_size = tcp_syn_options\n          tcp_header_size = tcp_options_size + sizeof(struct tcphdr);\n          -  skb_push(skb, tcp_header_size)\n          -  skb_reset_transport_header\n          -  skb_orphan\n          skb- destructor = tcp_wfree;\n          -  tcp_options_write\n          -  tcp_v4_send_check (icsk- icsk_af_ops- send_check)\n            -  __tcp_v4_send_check\n              skb- ip_summed == CHECKSUM_PARTIAL\n          -  ip_queue_xmit (icsk- icsk_af_ops- queue_xmit)\n            -  skb_push\n            -  skb_reset_network_header\n            iph- frag_off = htons(IP_DF);\n            -  ip_copy_addrs\n            -  ip_select_ident_segs\n            -  ip_local_out\n              -  __ip_local_out\n                -  ip_send_check\n                  -  ip_fast_csum\n                -  nf_hook { return 1; }\n              -  dst_output\n                -  ip_output (skb_dst(skb)- output)\n        -  inet_csk_reset_xmit_timer\n    sock- state = SS_CONNECTING;\n    err = -EINPROGRESS;\n    timeo = sock_sndtimeo() // NULL\n    return err  FIXME: add a diagram after  connect()", 
            "title": "connect"
        }, 
        {
            "location": "/kernel/callgraph/#receive-synack", 
            "text": "tcp_v4_rcv\n  -  __inet_lookup_skb\n    -  __inet_lookup\n      -  __inet_lookup_established  // found\n  -  tcp_v4_do_rcv  // sk_state == TCP_SYN_SENT\n    -  tcp_rcv_state_process\n      case TCP_SYN_SENT:\n      -  tcp_rcv_synsent_state_process\n        -  tcp_parse_options\n        if (th- ack)  // true\n        -  tcp_ecn_rcv_synack\n        -  tcp_init_wl\n        -  tcp_ack(FLAG_SLOWPATH)\n          // FLAG_SLOWPATH\n          -  tcp_ack_update_window\n            -  tcp_may_update_window  // true\n            -  tcp_update_wln\n            -  tcp_fast_path_check\n            -  tcp_sync_mss\n            -  tcp_snd_una_update\n          -  tcp_ecn_rcv_ecn_echo  // false\n          -  tcp_in_ack_event\n          -  tcp_clean_rtx_queue\n            -  tcp_ack_update_rtt\n            -  tcp_rearm_rto\n          -  tcp_rate_gen\n          -  tcp_cong_control\n          -  tcp_xmit_recovery\n        -  tcp_mtup_init\n        -  tcp_sync_mss\n        -  tcp_initialize_rcv_mss\n        -  tcp_finish_connect\n          -  tcp_set_state(sk, TCP_ESTABLISHED);\n          -  inet_sk_rx_dst_set (icsk- icsk_af_ops- sk_rx_dst_set)\n          -  inet_sk_rebuild_header (icsk- icsk_af_ops- rebuild_header)\n          -  tcp_init_metrics\n          -  tcp_init_congestion_control\n          -  tcp_init_buffer_space\n            -  tcp_fixup_rcvbuf\n            -  tcp_sndbuf_expand\n            -  tcp_full_space\n        -  tcp_send_ack\n          -  skb_reserve\n          -  tcp_init_nondata_skb\n          -  skb_set_tcp_pure_ack\n          -  skb_mstamp_get\n          -  tcp_transmit_skb\n            -  tcp_options_size = tcp_established_options  // 12\n            ...\n      -  tcp_urg\n      -  __kfree_skb\n      -  tcp_data_snd_check\n      return 0;", 
            "title": "Receive SYN+ACK"
        }, 
        {
            "location": "/kernel/callgraph/#read", 
            "text": "", 
            "title": "read"
        }, 
        {
            "location": "/kernel/callgraph/#write", 
            "text": "", 
            "title": "write"
        }, 
        {
            "location": "/lcc/", 
            "text": "Notes on LCC\n\n\nCallgraph of parsing expressions\n\n\n\n\nCallgraph of parsing statements\n\n\n\n\nCalltree of compiling an empty program\n\n\nCalltree of lcc 4.2\n for following simple program:\n\n\nint main()\n{\n  return 0;\n}", 
            "title": "lcc"
        }, 
        {
            "location": "/lcc/#notes-on-lcc", 
            "text": "", 
            "title": "Notes on LCC"
        }, 
        {
            "location": "/lcc/#callgraph-of-parsing-expressions", 
            "text": "", 
            "title": "Callgraph of parsing expressions"
        }, 
        {
            "location": "/lcc/#callgraph-of-parsing-statements", 
            "text": "", 
            "title": "Callgraph of parsing statements"
        }, 
        {
            "location": "/lcc/#calltree-of-compiling-an-empty-program", 
            "text": "Calltree of lcc 4.2  for following simple program:  int main()\n{\n  return 0;\n}", 
            "title": "Calltree of compiling an empty program"
        }, 
        {
            "location": "/lua/", 
            "text": "Notes on Lua implementation\n\n\nCalltree of Lua 5.3\n for following simple program:\n\n\nx = 10\nprint(x)", 
            "title": "Lua"
        }, 
        {
            "location": "/lua/#notes-on-lua-implementation", 
            "text": "Calltree of Lua 5.3  for following simple program:  x = 10\nprint(x)", 
            "title": "Notes on Lua implementation"
        }, 
        {
            "location": "/mem/", 
            "text": "Notes on C/C++ memory model\n\n\n\n\nThe C11 and C++11 Concurrency Model\n by Mark John Batty", 
            "title": "mem"
        }, 
        {
            "location": "/mem/#notes-on-cc-memory-model", 
            "text": "The C11 and C++11 Concurrency Model  by Mark John Batty", 
            "title": "Notes on C/C++ memory model"
        }, 
        {
            "location": "/ssl/", 
            "text": "Notes on SSL/TLS\n\n\nChaCha20, Poly1305, X25519\n\n\n\n\nRFC7539\n defines ChaCha20 and Poly1305\n\n\nRFC7905\n adds TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 (0xCCA8) etc to TLS 1.2\n\n\nThere is an old version of ECDHE_RSA_CHACHA20_POLY1305_OLD (0xCC13) exists in \ndraft\n and OpenSSL \ncode\n.\n\n\nOpenSSL will prefer AES if hardware supports it, otherwise prefer ChaCha20 over AES, in \nssl_create_cipher_list()\n.\n\n\nGo 1.8 will support TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 \ncommit 67d8226b48\n\n\n\n\ncommit 67d8226b4862f0f8deb4dc6fa8617017ecb0f32b\nAuthor: Adam Langley \nagl@golang.org\n\nDate:   Wed Oct 12 10:46:43 2016 -0700\n\n    crypto/tls: support ChaCha20-Poly1305.\n\n    This change adds support for the ChaCha20-Poly1305 AEAD to crypto/tls,\n    as specified in https://tools.ietf.org/html/rfc7905.\n\n    Fixes #15499.\n\n    Change-Id: Iaa689be90e03f208c40b574eca399e56f3c7ecf1\n    Reviewed-on: https://go-review.googlesource.com/30957\n    Run-TryBot: Adam Langley \nagl@golang.org\n\n    TryBot-Result: Gobot Gobot \ngobot@golang.org\n\n    Reviewed-by: Brad Fitzpatrick \nbradfitz@golang.org\n\n\n\n\n\n\n\nGo perfers X25519 over P-256, P-384 and P-521. \ncommit 9e98e7e668\n\n\n\n\ncommit 9e98e7e6686a500f87352e3721038d194b1db33c\nAuthor: Adam Langley \nagl@golang.org\n\nDate:   Tue Oct 11 15:08:35 2016 -0700\n\n    crypto/tls: enable X25519 by default.\n\n    Since this changes the offered curves in the ClientHello, all the test\n    data needs to be updated too.\n\n    Change-Id: I227934711104349c0f0eab11d854e5a2adcbc363\n    Reviewed-on: https://go-review.googlesource.com/30825\n    Reviewed-by: Brad Fitzpatrick \nbradfitz@golang.org\n\n\n\n\n\nAPI changes\n\n\n\n\nOpenSSL 1.0.2 has an undocumented \nSSL_get_server_tmp_key()\n function to get the curve used in handshaking, this is for \nopenssl s_client\n command. http://crypto.stackexchange.com/questions/11310/with-openssl-and-ecdhe-how-to-show-the-actual-curve-being-used\n\n\nOpenSSL 1.0.1 only allows setting one curve with \nSSL_CTX_set_tmp_ecdh()\n (or use callbacks), OpenSSL 1.0.2 allows setting curve list with \nSSL_CTX_set1_curves()\n and \nSSL_CTX_set1_curves_list()\n\n\nOpenSSL 1.0.2 adds \nSSL_CTX_set_ecdh_auto()\n, but OpenSSL 1.1.0 makes it a no-op.\n\n\n\n\nOpenSSL 1.1.0 provides \nSSL_SESSION_get_master_key()\n function.\n\n\n\n\n\n\nGo 1.8 supports KeyLogWriter \ncommit 320bd562cb\n\n\n\n\n\n\ncommit 320bd562cbb24a01beb02706c42d06a290160645\nAuthor: Joonas Kuorilehto \njoneskoo@derbian.fi\n\nDate:   Sat Aug 20 14:41:42 2016 +0300\n\n    crypto/tls: add KeyLogWriter for debugging\n\n    Add support for writing TLS client random and master secret\n    in NSS key log format.\n\n    https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format\n\n    Normally this is enabled by a developer debugging TLS based\n    applications, especially HTTP/2, by setting the KeyLogWriter\n    to an open file. The keys negotiated in handshake are then\n    logged and can be used to decrypt TLS sessions e.g. in Wireshark.\n\n    Applications may choose to add support similar to NSS where this\n    is enabled by environment variable, but no such mechanism is\n    built in to Go. Instead each application must explicitly enable.\n\n    Fixes #13057.\n\n    Change-Id: If6edd2d58999903e8390b1674ba4257ecc747ae1\n    Reviewed-on: https://go-review.googlesource.com/27434\n    Run-TryBot: Brad Fitzpatrick \nbradfitz@golang.org\n\n    TryBot-Result: Gobot Gobot \ngobot@golang.org\n\n    Reviewed-by: Brad Fitzpatrick \nbradfitz@golang.org\n\n\n\n\n\nMemory footprint\n\n\n\n\nBefore OpenSSL 1.1.0, there is a free-list (~32k per SSL) unless disable with OPENSSL_NO_BUF_FREELISTS or set SSL_MODE_RELEASE_BUFFERS, the free list is freed in \nSSL_CTX_free()\n not \nSSL_free()\n.\n\n\n\n\ncommit 63c574f6a6\n in OpenSSL:\n\n\ncommit 63c574f6a639cfa3f53476080054526e6bfa3bc9\nAuthor: Rich Salz \nrsalz@openssl.org\n\nDate:   Tue Jan 27 16:43:53 2015 -0500\n\n    OPENSSL_NO_XXX cleanup: OPENSSL_NO_BUF_FREELISTS\n\n    Remove OPENSSL_NO_BUF_FREELISTS. This was turned on by default,\n    so the work here is removing the 'maintain our own freelist' code.\n    Also removed a minor old Windows-multibyte/widechar conversion flag.\n\n\n\n\ncommit 72e56bc494\n in LibreSSL:\n\n\ncommit 72e56bc4947e53cec535f2fc84e00a3c278edf29\nAuthor: tedu \n\nDate:   Wed Apr 16 21:16:33 2014 +0000\n\n    TANSTAAFL - delete the buf freelist code. if you need a better malloc, get\n    a better malloc. ok beck deraadt\n\ndiff --git a/src/lib/libssl/s3_both.c b/src/lib/libssl/s3_both.c\n\n\n\n\nTANSTAAFL - There ain't no such thing as a free lunch\n\n\ncommit 983f6bdb58\n in BoringSSL:\n\n\ncommit 983f6bdb5888d7074d7ee67d5e3741bcf1027108\nAuthor: Alex Chernyakhovsky \nachernya@google.com\n\nDate:   Sun Aug 3 15:48:35 2014 -0400\n\n    Set OPENSSL_NO_BUF_FREELISTS\n\n    The memory freelist maintained by OpenSSL claims to be a performance\n    optimization for platforms that have a slow malloc/free\n    implementation. This should not be the case on modern\n    linux/glibc. Remove the freelist as it poses a potential security\n    hazard of buffer-reuse that is of \ninitialized\n memory that will not\n    be caught be tools such as valgrind.\n\n    Change-Id: I3cfa6a05f9bdfbbba7820060bae5a673dee43014\n    Reviewed-on: https://boringssl-review.googlesource.com/1385\n    Reviewed-by: Adam Langley \nagl@google.com\n\n\n\n\n\n\n\nAfter \ncommit b8d28cf532\n BoringSSL calls \nssl_write_buffer_flush()\n and \nssl_write_buffer_clear()\n for each \nSSL_write()\n, so its memory footprint is much smaller than other SSL libraries (~32k) when no data is pending.\n\n\n\n\nPerformance notes\n\n\nThe P-256 curve, also known as \nprime256v1\n or \nsecp256r1\n is widely used in ECDHE_RSA key exchange.\n\n\nFor x86-64, there is a faster implementation, enabled by \n./config enable-ec_nistp_64_gcc_128\n.\n\n\nFuther speed up of P-256 in OpenSSL 1.1.0 and BoringSSL:\n\n\n\n\ncommit 4d3fa06fce\n for OpenSSL 1.1.0\n\n\ncommit 3842a64d36\n backports to 1.0.2 branch\n\n\ncommit 1895493868\n for BoringSSL\n\n\n\n\ncommit 18954938684e269ccd59152027d2244040e2b819\nAuthor: Adam Langley \nagl@google.com\n\nDate:   Tue Nov 3 14:02:04 2015 -0800\n\n    Add Intel's P-256\n\n    This change incorporates Intel's P-256 implementation. The record of\n    Intel's submission under CLA is in internal bug number 25330687.\n\n    Before:\n    Did 3582 ECDH P-256 operations in 1049114us (3414.3 ops/sec)\n    Did 8525 ECDSA P-256 signing operations in 1028778us (8286.5 ops/sec)\n    Did 3487 ECDSA P-256 verify operations in 1008996us (3455.9 ops/sec)\n    build/tool/bssl is 1434704 bytes after strip -s\n\n    After:\n    Did 8618 ECDH P-256 operations in 1027884us (8384.2 ops/sec)\n    Did 21000 ECDSA P-256 signing operations in 1049490us (20009.7 ops/sec)\n    Did 8268 ECDSA P-256 verify operations in 1079481us (7659.2 ops/sec)\n    build/tool/bssl is 1567216 bytes after strip -s\n\n    Change-Id: I147971a8e19849779c8ed7e20310d41bd4962299\n    Reviewed-on: https://boringssl-review.googlesource.com/6371\n    Reviewed-by: Adam Langley \nagl@google.com\n\n\n\n\n\nNone of them are available in LibreSSL as of Jan 19, 2017. \nIssue 259\n.\n\n\nCryptography\n\n\n\n\ncs387 Applied Cryptography on udacity\n\n\nElliptic Curve Cryptography: ECDH and ECDSA\n\n\nEverything you need to know about cryptography in 1 hour", 
            "title": "SSL"
        }, 
        {
            "location": "/ssl/#notes-on-ssltls", 
            "text": "", 
            "title": "Notes on SSL/TLS"
        }, 
        {
            "location": "/ssl/#chacha20-poly1305-x25519", 
            "text": "RFC7539  defines ChaCha20 and Poly1305  RFC7905  adds TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 (0xCCA8) etc to TLS 1.2  There is an old version of ECDHE_RSA_CHACHA20_POLY1305_OLD (0xCC13) exists in  draft  and OpenSSL  code .  OpenSSL will prefer AES if hardware supports it, otherwise prefer ChaCha20 over AES, in  ssl_create_cipher_list() .  Go 1.8 will support TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256  commit 67d8226b48   commit 67d8226b4862f0f8deb4dc6fa8617017ecb0f32b\nAuthor: Adam Langley  agl@golang.org \nDate:   Wed Oct 12 10:46:43 2016 -0700\n\n    crypto/tls: support ChaCha20-Poly1305.\n\n    This change adds support for the ChaCha20-Poly1305 AEAD to crypto/tls,\n    as specified in https://tools.ietf.org/html/rfc7905.\n\n    Fixes #15499.\n\n    Change-Id: Iaa689be90e03f208c40b574eca399e56f3c7ecf1\n    Reviewed-on: https://go-review.googlesource.com/30957\n    Run-TryBot: Adam Langley  agl@golang.org \n    TryBot-Result: Gobot Gobot  gobot@golang.org \n    Reviewed-by: Brad Fitzpatrick  bradfitz@golang.org    Go perfers X25519 over P-256, P-384 and P-521.  commit 9e98e7e668   commit 9e98e7e6686a500f87352e3721038d194b1db33c\nAuthor: Adam Langley  agl@golang.org \nDate:   Tue Oct 11 15:08:35 2016 -0700\n\n    crypto/tls: enable X25519 by default.\n\n    Since this changes the offered curves in the ClientHello, all the test\n    data needs to be updated too.\n\n    Change-Id: I227934711104349c0f0eab11d854e5a2adcbc363\n    Reviewed-on: https://go-review.googlesource.com/30825\n    Reviewed-by: Brad Fitzpatrick  bradfitz@golang.org", 
            "title": "ChaCha20, Poly1305, X25519"
        }, 
        {
            "location": "/ssl/#api-changes", 
            "text": "OpenSSL 1.0.2 has an undocumented  SSL_get_server_tmp_key()  function to get the curve used in handshaking, this is for  openssl s_client  command. http://crypto.stackexchange.com/questions/11310/with-openssl-and-ecdhe-how-to-show-the-actual-curve-being-used  OpenSSL 1.0.1 only allows setting one curve with  SSL_CTX_set_tmp_ecdh()  (or use callbacks), OpenSSL 1.0.2 allows setting curve list with  SSL_CTX_set1_curves()  and  SSL_CTX_set1_curves_list()  OpenSSL 1.0.2 adds  SSL_CTX_set_ecdh_auto() , but OpenSSL 1.1.0 makes it a no-op.   OpenSSL 1.1.0 provides  SSL_SESSION_get_master_key()  function.    Go 1.8 supports KeyLogWriter  commit 320bd562cb    commit 320bd562cbb24a01beb02706c42d06a290160645\nAuthor: Joonas Kuorilehto  joneskoo@derbian.fi \nDate:   Sat Aug 20 14:41:42 2016 +0300\n\n    crypto/tls: add KeyLogWriter for debugging\n\n    Add support for writing TLS client random and master secret\n    in NSS key log format.\n\n    https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format\n\n    Normally this is enabled by a developer debugging TLS based\n    applications, especially HTTP/2, by setting the KeyLogWriter\n    to an open file. The keys negotiated in handshake are then\n    logged and can be used to decrypt TLS sessions e.g. in Wireshark.\n\n    Applications may choose to add support similar to NSS where this\n    is enabled by environment variable, but no such mechanism is\n    built in to Go. Instead each application must explicitly enable.\n\n    Fixes #13057.\n\n    Change-Id: If6edd2d58999903e8390b1674ba4257ecc747ae1\n    Reviewed-on: https://go-review.googlesource.com/27434\n    Run-TryBot: Brad Fitzpatrick  bradfitz@golang.org \n    TryBot-Result: Gobot Gobot  gobot@golang.org \n    Reviewed-by: Brad Fitzpatrick  bradfitz@golang.org", 
            "title": "API changes"
        }, 
        {
            "location": "/ssl/#memory-footprint", 
            "text": "Before OpenSSL 1.1.0, there is a free-list (~32k per SSL) unless disable with OPENSSL_NO_BUF_FREELISTS or set SSL_MODE_RELEASE_BUFFERS, the free list is freed in  SSL_CTX_free()  not  SSL_free() .   commit 63c574f6a6  in OpenSSL:  commit 63c574f6a639cfa3f53476080054526e6bfa3bc9\nAuthor: Rich Salz  rsalz@openssl.org \nDate:   Tue Jan 27 16:43:53 2015 -0500\n\n    OPENSSL_NO_XXX cleanup: OPENSSL_NO_BUF_FREELISTS\n\n    Remove OPENSSL_NO_BUF_FREELISTS. This was turned on by default,\n    so the work here is removing the 'maintain our own freelist' code.\n    Also removed a minor old Windows-multibyte/widechar conversion flag.  commit 72e56bc494  in LibreSSL:  commit 72e56bc4947e53cec535f2fc84e00a3c278edf29\nAuthor: tedu  \nDate:   Wed Apr 16 21:16:33 2014 +0000\n\n    TANSTAAFL - delete the buf freelist code. if you need a better malloc, get\n    a better malloc. ok beck deraadt\n\ndiff --git a/src/lib/libssl/s3_both.c b/src/lib/libssl/s3_both.c  TANSTAAFL - There ain't no such thing as a free lunch  commit 983f6bdb58  in BoringSSL:  commit 983f6bdb5888d7074d7ee67d5e3741bcf1027108\nAuthor: Alex Chernyakhovsky  achernya@google.com \nDate:   Sun Aug 3 15:48:35 2014 -0400\n\n    Set OPENSSL_NO_BUF_FREELISTS\n\n    The memory freelist maintained by OpenSSL claims to be a performance\n    optimization for platforms that have a slow malloc/free\n    implementation. This should not be the case on modern\n    linux/glibc. Remove the freelist as it poses a potential security\n    hazard of buffer-reuse that is of  initialized  memory that will not\n    be caught be tools such as valgrind.\n\n    Change-Id: I3cfa6a05f9bdfbbba7820060bae5a673dee43014\n    Reviewed-on: https://boringssl-review.googlesource.com/1385\n    Reviewed-by: Adam Langley  agl@google.com    After  commit b8d28cf532  BoringSSL calls  ssl_write_buffer_flush()  and  ssl_write_buffer_clear()  for each  SSL_write() , so its memory footprint is much smaller than other SSL libraries (~32k) when no data is pending.", 
            "title": "Memory footprint"
        }, 
        {
            "location": "/ssl/#performance-notes", 
            "text": "The P-256 curve, also known as  prime256v1  or  secp256r1  is widely used in ECDHE_RSA key exchange.  For x86-64, there is a faster implementation, enabled by  ./config enable-ec_nistp_64_gcc_128 .  Futher speed up of P-256 in OpenSSL 1.1.0 and BoringSSL:   commit 4d3fa06fce  for OpenSSL 1.1.0  commit 3842a64d36  backports to 1.0.2 branch  commit 1895493868  for BoringSSL   commit 18954938684e269ccd59152027d2244040e2b819\nAuthor: Adam Langley  agl@google.com \nDate:   Tue Nov 3 14:02:04 2015 -0800\n\n    Add Intel's P-256\n\n    This change incorporates Intel's P-256 implementation. The record of\n    Intel's submission under CLA is in internal bug number 25330687.\n\n    Before:\n    Did 3582 ECDH P-256 operations in 1049114us (3414.3 ops/sec)\n    Did 8525 ECDSA P-256 signing operations in 1028778us (8286.5 ops/sec)\n    Did 3487 ECDSA P-256 verify operations in 1008996us (3455.9 ops/sec)\n    build/tool/bssl is 1434704 bytes after strip -s\n\n    After:\n    Did 8618 ECDH P-256 operations in 1027884us (8384.2 ops/sec)\n    Did 21000 ECDSA P-256 signing operations in 1049490us (20009.7 ops/sec)\n    Did 8268 ECDSA P-256 verify operations in 1079481us (7659.2 ops/sec)\n    build/tool/bssl is 1567216 bytes after strip -s\n\n    Change-Id: I147971a8e19849779c8ed7e20310d41bd4962299\n    Reviewed-on: https://boringssl-review.googlesource.com/6371\n    Reviewed-by: Adam Langley  agl@google.com   None of them are available in LibreSSL as of Jan 19, 2017.  Issue 259 .", 
            "title": "Performance notes"
        }, 
        {
            "location": "/ssl/#cryptography", 
            "text": "cs387 Applied Cryptography on udacity  Elliptic Curve Cryptography: ECDH and ECDSA  Everything you need to know about cryptography in 1 hour", 
            "title": "Cryptography"
        }
    ]
}